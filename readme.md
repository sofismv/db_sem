## Тема 2. SQL-запросы

### 1. Теоретическая справка

#### 1.0 Введение

**Операторы SQL:**
<img src="img/img0_sql_statements.png"  width="500">

**Типы данных SQL:**
<img src="img/img1_sql_datatypes.png"  width="500">

**Операторы определения данных (Data Defenition Language):**

1. `CREATE` – создание объектов БД
```sql
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name(
    col_name_1   datatype_1,
    col_name_2   datatype_2,
    ...
    col_name_N   datatype_N
);
```

2. `ALTER` – модификация объектов БД
```sql
ALTER TABLE table_name ADD column_name datatype;
ALTER TABLE table_name DROP column_name;
ALTER TABLE table_name RENAME column_name TO new_column_name;
ALTER TABLE table_name ALTER column_name TYPE datatype;
...
```

3. `DROP` – удаление объектов БД 
```sql
DROP TABLE [IF EXISTS] table_name;
```

4. `TRUNCATE` – удаление содержимого объекта БД (данные удаляются целым куском, нельзя удалять по условию)
```sql
TRUNCATE TABLE table_name;
```

**Операторы манипуляции данными (Data Manipulation Language):**

1. `SELECT` – выбирает данные, удовлетворяющие заданным условиям
2. `INSERT` – добавляет новые данные
```sql
INSERT INTO table_name [(comma_separated_column_names)] VALUES (comma_separated_values);
```

3. `UPDATE` – изменяет (обновляет) существующие данные
```sql
UPDATE table_name
    SET update_assignment_comma_list
WHERE conditional_experssion;
```

4. `DELETE` – удаляет существующие данные (данные удаляются построчно – можно задавать условие, "откатывать" удаление)
```sql
DELETE
    FROM table_name
[WHERE conditional_expression];
```


#### 1.1 Структура запроса

Порядок написания запроса:

```sql
SELECT [DISTINCT] select_item_comma_list -- список столбцов для вывода
FROM table_reference_comma_list -- список таблиц
[WHERE conditional_expression] -- условия фильтрации, можно использовать AND / OR / NOT
[GROUP BY column_name_comma_list] -- условие группировки
[HAVING conditional_expression] -- условие фильтрации после группировки
[ORDER BY order_item_comma_list]; -- список полей, по которым сортируется вывод
```

#### 1.2 Порядок выполнения запроса

Порядок выполнения запроса отличается от порядка его записи, это необходимо помнить:

**FROM <span>&#8594;</span> WHERE <span>&#8594;</span> GROUP BY <span>&#8594;</span> HAVING <span>&#8594;</span> SELECT <span>&#8594;</span> ORDER BY**

####  1.3 Агрегирующие функции
					
При группировке в блоке `SELECT` могут встречаться либо атрибуты, по которым происходит группировка, либо атрибуты, которые подаются на вход агрегирующим функциям. В SQL есть 5 стандартных агрегирующих функций. При выполнении запроса функции не учитывается специальное значение `NULL`, которым обозначается отсутствующее значение.
					
* `count()` – количество записей с известным значением. Если необходимо подсчитать количество уникальных значений, можно использовать `count(DISTINCT field_nm)`
* `max()` - наибольшее из всех выбранных значений поля
* `min()` - наименьшее из всех выбранных значений поля
* `sum()` - сумма всех выбранных значений поля
* `avg()` - среднее всех выбранных значений поля

					 					
#### 1.4 Операции соединения таблиц (JOIN)
					
Операции соединения делятся на 3 группы:
					
* `CROSS JOIN` - декартово произведение 2 таблиц
* `INNER JOIN` - соединение 2 таблиц по условию. В результирующую выборку попадут только те записи, которые удовлетворяют условию соединения
* `OUTER JOIN` - соединение 2 таблиц по условию. В результирующую выборку могут попасть записи, которые не удовлетворяют условию соединения: 
    * `LEFT (OUTER) JOIN` - все строки "левой" таблицы попадают в итоговую выборку
    * `RIGHT (OUTER) JOIN` - все строки "правой" таблицы попадают в итоговую выборку 
    * `FULL (OUTER) JOIN` - все строки обеих таблиц попадают в итоговую выборку

<img src="img/img3_sql_join.png"  width="500">

#### 1.5 Полезные функции

Иногда бывает полезно использовать в запросе специальные функции:
* `IN` - принадлежность определенному набору значений:
`X IN (a1, a2, ..., an)` <span>&#8803;</span> X = a<sub>1</sub> or X = a<sub>2</sub> or ... or X = a<sub>n</sub>
* `BETWEEN` - принадлежность определенному интервалу значений:
`X BETWEEN A AND B` <span>&#8803;</span> (X >= A and X <= B) or (X <= A and X >= B)
* `LIKE` - удовлетворение текста паттерну: `X LIKE '0%abc_0'`, где `_` - ровно 1 символ, а `%` - любая последовательность символов (в том числе нулевой длины).
* `IF ... THEN ... [ELSIF ... THEN ... ELSE ...] END IF` - ветвления, **пример**:
```postgresql
SELECT
    IF number = 0 THEN
        'zero'
    ELSIF number > 0 THEN
        'positive'
    ELSIF number < 0 THEN
        'negative'
    ELSE
        'NULL'
    END IF AS number_class
FROM
    numbers
```
* `CASE [...] WHEN ... THEN ... ELSE ... END CASE` - еще один аналог ветвлений, **пример**:
```postgresql
SELECT
    CASE 
        WHEN number = 0 THEN
            'zero'
        WHEN number > 0 THEN
            'positive'
        WHEN number < 0 THEN
            'negative'
        ELSE
            'NULL'
    END CASE AS number_class
FROM
    numbers
```
* `DISTINCT ON` - исключает строки, совпадающие по всем указанным выражениям, **пример**:
```postgresql
-- вывести кол-во уникальных отделов
SELECT
    count(DISTINCT ON department_nm)
FROM
    salary;
```
* [Еще немного полезностей](https://postgrespro.ru/docs/postgresql/9.5/functions-conditional)

#### 1.6 Ключевое слово `WITH`
`WITH` предоставляет способ записывать дополнительные операторы для применения в больших запросах. 
Эти операторы, которые также называют общими табличными выражениями (Common Table Expressions, CTE), 
можно представить как определения временных таблиц, существующих только для одного запроса. 
Более подробно про СТЕ будет на следующих семинарах.
**Пример**:
```postgresql
WITH 
    regional_sales AS (
        SELECT 
            region, 
            SUM(amount) AS total_sales
        FROM 
            orders
        GROUP BY 
            region
    ), 
    top_regions AS (
        SELECT 
            region
        FROM 
            regional_sales
        WHERE 
            total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
   )
SELECT 
    region,
    product,
    SUM(quantity) AS product_units,
    SUM(amount) AS product_sales
FROM 
    orders
WHERE 
    region IN (SELECT region FROM top_regions)
GROUP BY 
    region, 
    product;
```

### 2. Практическое задание

1. Создать схему `topic_2`:

```sql
CREATE SCHEMA topic_2;
```

2. Создать таблицу `topic_2.salary` в новой схеме с полями `employee_nm, department_nm, salary`. Какого типа должны быть поля? Какой должна быть размерность этих полей?

3. Проверить, что таблица создана, написав запрос к системной таблице `information_schema.tables`.

4. Заполнить таблицу 5 тестовыми строками.

5. Добавить в таблицу новое поле `comment`.

6. Написать запрос для обновления поля с комментарием. Для каждой строки необходимо указать свой комментарий. Подумайте, как это сделать одной операций `UPDATE`, а не пятью разными запросами.

7. Удалить одну из строк таблицы на выбор.

8. Очистить таблицу, используя оператор группы DDL.

9. Удалить из таблицы столбец с комментарием.

10. Запустить запросы со вставками данных, полученные от семинариста.

11. Вывести все значения из таблицы `topic_2.salary`.

12. Найти всех сотрудников с зарплатой выше 500.

13. Найти всех сотрудников с зарплатой ниже 400 из отдела HR.

14. Найти всех сотрудников, зарплата которых лежит в диапазоне от 300 до 500.

15. Найти всех сорудников, в имени (не фамилии) которых встречается буква 'A', с зарплатой не менее 100. Считаем, что имя и фамилия разделены одним пробелом.

16. Вывести всех сотрудников из отделов HR и PR, не успользуя оператор `OR`.

17. Найти все отделы, названия которых состоят ровно из 2 символов. Вывести каждый отдел ровно 1 раз.

18. Найти все отделы, названия которых начинаются на букву 'S'. Вывести каждый отдел столько раз, сколько он встречается в таблице.

19. Вывести всех сотрудников, которые не работают в отделах 'R&D' и 'SUPPORT', не используя операторы `OR` и `AND`.

20. Вывести все отделы в названии которых встречаются буквы 'A' и 'E'. Порядок следования букв в названии значения не имеет.

21. Найти количество строк в таблице `topic_2.salary`.

22. Найти максимальную зарплату по всем сотрудникам.

23. Посчитать число сотрудников с зарплатой выше 500.

24. Найти среднюю зарплату в разбивке по отделам.

25. Найти все отделы со средней зарплатой свыше 300.

26. Найти все города с минимальной зарплатой свыше 500.

27. Найти все отделы с числом сотрудников не менее 10 человек.

28. Вывести список всех сострудников, отсортированный по убыванию зарплаты.

29. Вывести список всех отделов по убыванию средней зарплаты в отделе, а также среднюю, минимальную, максимальную зарплаты и количество человек в отделе.

30. Подсчитать отклонение максимальной зарплаты по всех отделах от минимальной и средней.

31. Для каждого отдела рассчитать отклонепние максимальной зарплаты от средней и минимальной, а также отклонение средней от минимальной.

32. Вывести отделы по возрастанию фонда оплаты труда.

---

### Полезные ссылки
* [SQLize.online is a free online SQL environment for quickly running, experimenting with and sharing SQL code.](https://sqlize.online/sql/psql14/9cffb8e3d397e93627eb41cd55b10c20/)
